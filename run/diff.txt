diff gkvp/src/gkvp_advnc.f90 src/gkvp_advnc.f90
19c19
<   use GKV_colliimp, only: colliimp_calc_colli_full, colliimp_set_param
---
>   use GKV_colliimp, only: colliimp_calc_colli_full
25d24
<   use GKV_geom, only: geom_increment_time
97,107d95
<        !%%% For shearflow rotating flux tube model %%%
<         if (gamma_e /= 0._DP .and. trim(flag_shearflow) == "rotating") then
<           if (istep == 2 .or. istep == 4) then
<             call geom_increment_time(0.5_DP * dt)
<             if (trim(col_type) == "full" .or. trim(col_type) == "lorentz" .or. trim(time_advnc) == "imp_colli") then
<               call colliimp_set_param
<             end if
<           end if
<         end if
<        !%%%
< 
494c482
<     real(kind=DP) :: cefv, cs1, rotating_cf4, rotating_up5
---
>     real(kind=DP) :: cefv, cs1
509,517d496
<      !%%% For shearflow rotating flux tube model %%%
<       if (gamma_e /= 0._DP .and. trim(flag_shearflow) == "rotating") then
<         rotating_cf4 = - gamma_e / (s_hat_g * 12._DP * (zz(0)-zz(-1)))
<         rotating_up5 = - gamma_e / (s_hat_g * 60._DP * (zz(0)-zz(-1)))
<       else
<         rotating_cf4 = 0._DP
<         rotating_up5 = 0._DP
<       end if
<      !%%%
527,530c506
<               !%%% For shearflow rotating flux tube model %%%
<               !!!- vl(iv) * cefz(iz) * (              &
<                  - (vl(iv) * cefz(iz) + rotating_cf4) * ( &
<               !%%%
---
>                  - vl(iv) * cefz(iz) * (              &
567,573d542
<                     !%%% For shearflow rotating flux tube model %%%
<                      - rotating_cf4 * (                   &
<                          -         ff(mx,my,iz+2,iv)      &
<                          + 8._DP * ff(mx,my,iz+1,iv)      &
<                          - 8._DP * ff(mx,my,iz-1,iv)      &
<                          +         ff(mx,my,iz-2,iv) )    &
<                     !%%%
602,608d570
<                     !%%% For shearflow rotating flux tube model %%%
<                      - rotating_cf4 * (                   &
<                          -         ff(mx,my,iz+2,iv)      &
<                          + 8._DP * ff(mx,my,iz+1,iv)      &
<                          - 8._DP * ff(mx,my,iz-1,iv)      &
<                          +         ff(mx,my,iz-2,iv) )    &
<                     !%%%
Only in gkvp/src/: gkvp_geom.f90
diff gkvp/src/gkvp_header.f90 src/gkvp_header.f90
41,43c41,43
<   integer, parameter :: nxw = 20, nyw = 20
<   integer, parameter :: nx = 4, global_ny = 1 ! 2/3 de-aliasing rule
<   integer, parameter :: global_nz = 12, global_nv = 24, global_nm = 7
---
>   integer, parameter :: nxw = 2, nyw = 20
>   integer, parameter :: nx = 0, global_ny = 12 ! 2/3 de-aliasing rule
>   integer, parameter :: global_nz = 48, global_nv = 24, global_nm = 15
52c52
<   integer, parameter :: nprocw = 1, nprocz = 2, nprocv = 4, nprocm = 2, nprocs = 1
---
>   integer, parameter :: nprocw = 2, nprocz = 4, nprocv = 2, nprocm = 2, nprocs = 1
172c172
<   real(kind=DP) :: mach, uprime, gamma_e, kxmin_g, kymin_g, tlim_exb, s_hat_g
---
>   real(kind=DP) :: mach, uprime, gamma_e, kxmin_g, kymin_g, tlim_exb
203,207d202
< 
<   !character(15)  :: flag_shearflow = "remap"   ! Wavevector remap method
<   !                                             ! with nearest grid approximation
<   !                                             ! (Discontinuous in time)
<   character(15)  :: flag_shearflow = "rotating" ! Rotating flux tube model
diff gkvp/src/gkvp_main.f90 src/gkvp_main.f90
139c139
<       if (gamma_e /= 0._DP .and. trim(flag_shearflow) == "remap") then
---
>       if (gamma_e /= 0._DP) then
diff gkvp/src/gkvp_set.f90 src/gkvp_set.f90
24c24,25
<   use GKV_math,   only: math_random
---
>   use GKV_math,   only: math_j0, math_j1, math_j2, math_g0, math_random
>   use GKV_intgrl, only: intgrl_fsrf, intgrl_v0_moment_ms
28a30,35
> ! for vmec equilibrium
> ! use GKV_vmecin, only: vmecin_fileopen, vmecin_coeff, vmecin_read
> ! for vmec equilibrium w/ Booz_xform by M. Nakata & M. Nunami  (Aug. 2016)
>   use GKV_vmecbzx, only: vmecbzx_boozx_read, vmecbzx_boozx_coeff
> ! for tokamak(eqdsk) equilibrium
>   use GKV_igs,    only: igs_read, igs_coeff
35,37d41
<   use GKV_geom, only : geom_read_nml, geom_init_kxkyzvm,      &
<                        geom_init_metric, geom_set_operators,  &
<                        geom_reset_time
44a49
> 
391a397,443
>     real(kind=DP) :: s_hat
> 
>     real(kind=DP) :: eps_r
> 
>     real(kind=DP) :: rdeps00, eps_hor, lprd, mprd, lmmq, malpha
>     real(kind=DP) :: eps_mor, eps_por, lprdm1, lprdp1, lmmqm1, lmmqp1
>     real(kind=DP) :: eps_rnew, rdeps1_0, rdeps1_10, rdeps2_10, rdeps3_10
> 
> ! for s-alpha model with Shafranov shift
>     real(kind=DP) ::  p_total, dp_totaldx, beta_total, alpha_MHD
> 
> ! for circular MHD
>     real(kind=DP), dimension(1:3,1:3) :: gg
>     real(kind=DP) :: kkx, kky, domgdz, domgdx, domgdy
> 
> 
> !! for vmec equilibrium
> !    real(kind=DP) :: rho2R_0, q_input, theta
> !    real(kind=DP) :: r_0
> !    real(kind=DP) :: gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz, &
> !                     gupss, guptt, gupzz, gupst, gupsz, guptz, &
> !                     babs, Bs  , Bth , Bzt , dBds, dBdt, dBdz, &
> !                     dBdt_mir, vmec_rootg, rootgft, rootgbz
>     real(kind=DP) :: theta
> 
> 
>     real(kind=DP) :: lx, ly, lz, kxmin, kymin, dz, mmax, dm, del_c
>     real(kind=DP) :: lz_l, z0, z0_l
>     integer       :: n_tht, m_j
> 
>     real(kind=DP) :: gg0
> 
>     real(kind=DP) :: bb, kmo
>     real(kind=DP) :: cfsrf_l
> 
>     integer       :: global_iv, global_im
>     integer       :: mx, my, iz, iv, im, is, is1, is2, ierr_mpi
> 
> 
>     complex(kind=DP), dimension(:,:,:,:,:), allocatable :: wf
>     complex(kind=DP), dimension(:,:,:), allocatable :: nw
>     real(kind=DP), dimension(:,:,:), allocatable :: ww
> 
> !    real(kind=DP) :: rad_a, r_minor, eps_b, rho_unit, r_a
> !    real(kind=DP) :: R0_unit, r_edge, b0b00, alpha_fix
> 
>     real(kind=DP), dimension(0:ns-1) :: eta
393,394c445
<     real(kind=DP) :: lx, ly, eps_r
<     integer       :: is1, is2
---
>     real(kind=DP) :: r_major
395a447,489
>     real(kind=DP) :: s_input, s_0      ! radial label of fluxtube center 
>     integer       :: mc_type           ! 0:Axisym., 1:Boozer, 2:Hamada
>     integer       :: q_type            ! 0:use q and s_hat value in confp, 1:calclated by IGS
>     integer       :: isw, nss, ntheta, nzeta
>     real(kind=DP) :: phi_ax            ! axisymetric toroidal angle 
> 
>     integer, parameter :: num_omtr = 13
>     real(kind=DP) :: metric_l(1:num_omtr,-nz:nz-1), metric_g(1:num_omtr,-global_nz:global_nz-1)
> 
> 
> 
> 
>     namelist /physp/ R0_Ln,  &    ! R0/Lns
>                      R0_Lt,  &    ! R0/Lts
>                         nu,  &    ! factor for collision freq. in LB model    
>                       Anum,  &    ! mass number
>                       Znum,  &    ! charge number 
>                        fcs,  &    ! charge-density fraction 
>                        sgn,  &    ! signs of charge 
>                        tau,  &    ! T-ratio Ts/T0, T0=reference ion temp. of ranks=1
>                       dns1,  &    ! initial perturbation amplitude
>                     tau_ad,  &    ! Ti/Te for ITG-ae, Te/Ti for ETG-ai
>                   lambda_i,  &    ! (Debye/rho_tp)^2 
>                       beta,  &    ! mu0*ni*Ti/B^2
>                    ibprime,  &    ! flag for finite beta-prime effect on kvd
>                       vmax,  &    ! maximum v_para in unit of v_ts
>                        nx0        ! mode number for the initial perturbation
> 
>     namelist /rotat/ mach, uprime, gamma_e
> 
>     namelist /nperi/ n_tht, kymin, m_j, del_c
>     namelist /confp/ eps_r, eps_rnew,                       &
>                      q_0, s_hat,                            &
>                      lprd, mprd, eps_hor, eps_mor, eps_por, &
>                      rdeps00, rdeps1_0, rdeps1_10,          & 
>                      rdeps2_10, rdeps3_10, malpha
> !    namelist /vmecp/ q_0, rad_a,                            &
> !                     R0_unit, r_edge,                       &
> !                     b0b00, alpha_fix
>     namelist /vmecp/ s_input, nss, ntheta, nzeta
> 
>     namelist /igsp/ s_input, mc_type, q_type, nss, ntheta
> 
403,404c497,1787
< ! --- read GKV namelist relating to configurations ---
<         call geom_read_nml
---
>       tau(:)   = 1.0_DP
>       nu(:)    = 0.002_DP
>       R0_Ln(:) = 2.5_DP
>       R0_Lt(:) = 7.5_DP
> 
> 
>       read(inml,nml=physp)
> 
> 
>         do is = 0, ns-1
>           if( R0_Ln(is) /= 0._DP ) then
>             eta(is) = R0_Lt(is) / R0_Ln(is)
>           else
>             eta(is) = 1.d+20
>           end if
>         end do
> 
> 
>         write( olog, * ) " # Physical parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # r_major/L_ns = ", R0_Ln(:)
>         write( olog, * ) " # r_major/L_ts = ", R0_Lt(:)
>         write( olog, * ) " # eta          = ", eta(:)
>         write( olog, * ) " # nu           = ", nu(:)
>         write( olog, * ) " # A-number     = ", Anum(:)
>         write( olog, * ) " # Z-number     = ", Znum(:)
>         write( olog, * ) " # fcs          = ", fcs(:)
>         write( olog, * ) " # sgn          = ", sgn(:)
>         write( olog, * ) " # tau          = ", tau(:)
>         write( olog, * ) " # dns1         = ", dns1(:)
>         write( olog, * ) " # tau_ad       = ", tau_ad
>         write( olog, * ) " # lambda_i^2   = ", lambda_i
>         write( olog, * ) " # beta_i       = ", beta
>         write( olog, * ) " # ibprime      = ", ibprime
>         write( olog, * ) " # nx0          = ", nx0
>         write( olog, * ) ""
> 
> 
>       mach = 0._DP
>       uprime = 0._DP
>       gamma_e = 0._DP
> 
>       read(inml,nml=rotat)
> 
>         write( olog, * ) " # Mean rotation parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # Mach number  = ", mach
>         write( olog, * ) " # uptime       = ", uprime
>         write( olog, * ) " # gamma_ExB    = ", gamma_e
>         write( olog, * ) ""
> 
> 
>       n_tht = 1
> 
>       read(inml,nml=nperi)
> 
> 
>       if( trim(equib_type) == "slab") then
> 
>         read(inml,nml=confp)
> 
>         lprdm1   = 0._DP
>         lprdp1   = 0._DP
> 
>         lmmq     = 0._DP
>         lmmqm1   = 0._DP
>         lmmqp1   = 0._DP
> 
>         q_0      = 1._DP ! For now, fixed q_0=1. Changing q_0 can extend parallel z-box size.
>         s_hat    = 0._DP ! only shear less slab
>         eps_r    = 1._DP
> 
>         eps_hor  = 0._DP
>         lprd     = 0._DP
>         mprd     = 0._DP
>         malpha   = 0._DP
> 
>         rdeps00  = 0._DP
>         eps_mor  = 0._DP
>         eps_por  = 0._DP
> 
>         write( olog, * ) " # Configuration parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # q_0          = ", q_0
>         write( olog, * ) " # s_hat        = ", s_hat
>         write( olog, * ) " # eps_r        = ", eps_r
>         write( olog, * ) ""
> 
>         write( olog, * ) " # eps_hor      = ", eps_hor
>         write( olog, * ) " # lprd         = ", lprd
>         write( olog, * ) " # mprd         = ", mprd
>         write( olog, * ) " # malpha       = ", malpha
>         write( olog, * ) " # rdeps00      = ", rdeps00
> 
>         write( olog, * ) " # eps_mor      = ", eps_mor
>         write( olog, * ) " # lprdm1       = ", lprdm1
>         write( olog, * ) " # eps_por      = ", eps_por
>         write( olog, * ) " # lprdp1       = ", lprdp1
>         write( olog, * ) ""
> 
>       else if( trim(equib_type) == "analytic"  .OR.  &
>                trim(equib_type) == "s-alpha"   .OR.  &
>                trim(equib_type) == "s-alpha-shift"   .OR.  &
>                trim(equib_type) == "circ-MHD" ) then
> 
> 
>         read(inml,nml=confp)
> 
> 
>         lprdm1   = lprd - 1.0_DP
>         lprdp1   = lprd + 1.0_DP
> 
>         lmmq     = lprd   - mprd * q_0
>         lmmqm1   = lprdm1 - mprd * q_0
>         lmmqp1   = lprdp1 - mprd * q_0
> 
> 
>         write( olog, * ) " # Configuration parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # q_0          = ", q_0
>         write( olog, * ) " # s_hat        = ", s_hat
>         write( olog, * ) " # eps_r        = ", eps_r
>         write( olog, * ) ""
> 
>         write( olog, * ) " # eps_hor      = ", eps_hor
>         write( olog, * ) " # lprd         = ", lprd
>         write( olog, * ) " # mprd         = ", mprd
>         write( olog, * ) " # malpha       = ", malpha
>         write( olog, * ) " # rdeps00      = ", rdeps00
> 
>         write( olog, * ) " # eps_mor      = ", eps_mor
>         write( olog, * ) " # lprdm1       = ", lprdm1
>         write( olog, * ) " # eps_por      = ", eps_por
>         write( olog, * ) " # lprdp1       = ", lprdp1
>         write( olog, * ) ""
> 
> 
> 
> !      else if( trim(equib_type) == "vmec" ) then
> !
> !
> !! --- Paramters at rho=0.65 (shot#088343 at t = 1.833 [s])
> !!
> !!        Ln_unit =-4.230701_DP                      ! Ln [m]
> !!        Lt_unit = 0.3135611_DP                     ! Lt [m]
> !!        R0_unit = 3.599858_DP                      ! R0 [m]
> !!        r_edge  = 0.6362872D0                      ! r_edge [m]
> !!        b0b00   = 2.88846853946973647d0/2.940307D0 ! b00mode/B0
> !!        alpha_fix = 0.314159253589793d0            ! pi/10
> !!
> !
> !        read(inml,nml=vmecp)
> !
> !        eps_b      = r_edge / R0_unit   ! --- a / R                  ! by nunami (2010.04.21)
> !
> !        rho2R_0  = eps_b / rad_a               ! --- rho / R_0
> !        rho_unit = rho2R_0 * R0_unit           ! --- rho
> !        r_a      = rad_a * rho2R_0             ! --- rad_a / R_0
> !
> !        eps_r = 0.1115200537d0
> !
> !        call vmecin_fileopen
> !
> !
> !        call vmecin_read
> !
> !
> !        q_input = q_0
> !        theta   = 0._DP
> !
> !        call vmecin_coeff( rad_a, R0_unit, rho2R_0, q_input, theta,  &
> !                           alpha_fix, r_0, r_minor, s_hat,           &
> !                           gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz, &
> !                           gupss, guptt, gupzz, gupst, gupsz, guptz, &
> !                           babs, Bs, Bth, Bzt, dBds, dBdt, dBdz,     &
> !                           dBdt_mir, vmec_rootg, rootgft, rootgbz )
> !
> !
> !        write( olog, * ) " # Configuration parameters"
> !        write( olog, * ) ""
> !        write( olog, * ) " # q_0          = ", q_0
> !        write( olog, * ) " # s_hat        = ", s_hat
> !        write( olog, * ) ""
> !        write( olog, * ) " # eps_r        = ", eps_r
> !        write( olog, * ) ""
> 
> 
>      else if( trim(equib_type) == "vmec" ) then
> 
> 
>         read(inml,nml=confp)
> 
>         read(inml,nml=vmecp)
> 
>         call vmecbzx_boozx_read( nss, ntheta, nzeta )
> 
>          isw = 0
>          iz = 0
>          call vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input, iz, 0._DP,  lz_l,   &  ! input 
>                            s_0,           q_0,     s_hat,    eps_r,  phi_ax,             &  ! output
>                            omg(iz), rootg(iz),    domgdx,   domgdz,  domgdy,             &
>                            gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                      &
>                            gg(2,3),   gg(3,3)  )
> 
> 
> 
>         write( olog, * ) " # Configuration parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # r_major/L_ns = ", R0_Ln(:)
>         write( olog, * ) " # r_major/L_ts = ", R0_Lt(:)
>         write( olog, * ) " # eta          = ", eta(:)
>         write( olog, * ) " # q_0          = ", q_0
>         write( olog, * ) " # s_hat        = ", s_hat
>         write( olog, * ) " # eps_r        = ", eps_r
>         write( olog, * ) " # s_input, s_0 = ", s_input, s_0
>         write( olog, * ) " # nss, ntheta, nzeta  = ", nss, ntheta, nzeta
> 
> 
>      else if( trim(equib_type) == "eqdsk" ) then
> 
> 
>         read(inml,nml=confp)
> 
>         read(inml,nml=igsp)
> 
>         call igs_read( mc_type, nss, ntheta )
> 
>         if ( q_type == 1 ) then
>          isw = 0
>          iz = 0
>          call igs_coeff( isw,  mc_type,   nss,    ntheta,  s_input,  0._DP, lz_l,   &  ! input 
>                          s_0,       q_0,     s_hat,    eps_r,  theta,               &  ! output
>                            omg(iz), rootg(iz),    domgdx,   domgdz, domgdy,         &
>                            gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                 &
>                            gg(2,3),   gg(3,3)  )
>         end if
> 
> 
> 
>         write( olog, * ) " # Configuration parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # r_major/L_ns = ", R0_Ln(:)
>         write( olog, * ) " # r_major/L_ts = ", R0_Lt(:)
>         write( olog, * ) " # eta          = ", eta(:)
>         write( olog, * ) " # q_0          = ", q_0
>         write( olog, * ) " # s_hat        = ", s_hat
>         write( olog, * ) " # eps_r        = ", eps_r
>         write( olog, * ) " # s_input, s_0 = ", s_input, s_0
>         write( olog, * ) " # nss, ntheta  = ", nss, ntheta
> 
>       else
> 
>         write( olog, * ) " # wrong choice of the equilibrium "
>         call flush(olog)
>         call MPI_Finalize(ierr_mpi)
>         stop
> 
>       end if
> 
> 
> ! --- coordinate settings ---
> 
>         if (abs(s_hat) < 1.d-10) then ! When s_hat == ZERO
>           m_j = 0
>           kxmin = kymin
>         else if (m_j == 0) then
>           kxmin = kymin
>         else
>           kxmin    = abs(2._DP * pi * s_hat * kymin / real(m_j, kind=DP))
>         end if
>         lx       = pi / kxmin
>         ly       = pi / kymin
>                       ! kymin=pi/ly=pi/[r_minor*pi/(q0*n_alp)]=q0*n_alp/r_minor
> 
>         lz       = real( n_tht, kind=DP ) * pi        ! total z-length
>         lz_l     = lz / real( nprocz, kind=DP )       ! local z-length
> 
>         do mx = -nx, nx
>           kx(mx)   = kxmin * real( mx, kind=DP )
>         end do
> 
>         ky(:) = 0._DP
>         do my = ist_y_g, iend_y_g
>           ky(my-ist_y_g)   = kymin * real( my, kind=DP )
>         end do
> 
>         kxmin_g = kxmin
>         kymin_g = kymin 
> 
>         z0       = - lz                     ! global lower boundary
>         z0_l     = 2._DP * lz_l * real( rankz, kind=DP ) + z0
>                                             ! local lower boundary
> 
>         dz       = lz_l / real( nz, kind=DP )
> 
>         do iz = -nz, nz-1
>           zz(iz)   = dz * real( iz + nz, kind=DP ) + z0_l
>         end do
> 
> 
>         dv       = 2._DP * vmax / real( 2 * nv * nprocv -1, kind=DP )
> 
>         do iv = 1, 2*nv
>           global_iv = 2 * nv * rankv + iv
>           vl(iv)    = dv * ( real( global_iv - nv * nprocv - 1, kind=DP ) + 0.5_DP )
>         end do
>                                             ! --- debug
>                                             !   write( olog, * ) " *** iv, vl "
>                                             !   do iv = 1, 2*nv
>                                             !     global_iv = 2 * nv * rankv + iv
>                                             !     write( olog, * ) iv, global_iv, vl(iv)
>                                             !   end do
>                                             !   write( olog, * ) ""
> 
>         mmax     = vmax
>         dm       = mmax / real( nprocm * ( nm+1 ) - 1, kind=DP )
>                                             ! --- equal spacing in vperp
> 
>         do im = 0, nm
>           global_im = ( nm+1 ) * rankm + im
>           mu(im)    = 0.5_DP * ( dm * real( global_im, kind=DP ) )**2
>         end do
> 
> 
>         write( olog, * ) " # Numerical parameters"
>         write( olog, * ) ""
>         write( olog, * ) " # n_tht = ", n_tht
>         write( olog, * ) " # lx, ly, lz   = ", lx, ly, lz
>         write( olog, * ) " # lz,   z0     = ", lz, z0
>         write( olog, * ) " # lz_l, z0_l   = ", lz_l, z0_l
>         write( olog, * ) " # kxmin, kymin = ", kxmin, kymin
>         write( olog, * ) " # kxmax, kymax = ", kxmin*nx, kymin*global_ny
>         write( olog, * ) " # kperp_max    = ", sqrt((kxmin*nx)**2+(kymin*global_ny)**2)
>         write( olog, * ) " # m_j, del_c   = ", m_j, del_c
>         write( olog, * ) " # dz           = ", dz
>         write( olog, * ) " # dv, vmax     = ", dv, vmax
>         write( olog, * ) " # dm, mmax     = ", dm, mmax
>         write( olog, * ) ""
> 
>         if (gamma_e == 0._DP) then
>           tlim_exb = 999999.d0
>         else
>           tlim_exb = (kxmin*(nx-nx0))/(kymin*global_ny*abs(gamma_e))
>         end if
>         write( olog, * ) " # ExB limit time tlim_exb  = ", tlim_exb
>         write( olog, * ) " # for (mx=nx0,my=global_ny) initial perturbation: "
>         write( olog, * ) " # tlim_exb = kxmin*(nx-nx0)/(kymax*|gamma_e|)"
>         write( olog, * ) ""
> 
> 
> ! --- coordinate settings ---
> 
>  
> ! --- operator settings ---
> 
> 
>         do iz = -nz, nz-1
> 
> !!! for slab model
>           if ( trim(equib_type) == "slab") then
> 
>             q_bar = q_0 
>             r_major = 1._DP ! in the R0 unit
>             theta = zz(iz)
> 
>             omg(iz)   = 1._DP
>             rootg(iz) = q_0*r_major
>             dpara(iz) = dz * q_0 * r_major
> 
>             do im = 0, nm
>               vp(iz,im)  = sqrt( 2._DP * mu(im) )!* omg(iz) )
>               mir(iz,im) = 0._DP
>               do iv = 1, 2*nv
>                 vdx(iz,iv,im) = 0._DP
>                 vdy(iz,iv,im) = 0._DP
>                 vsy(iz,iv,im) =                                           &
>                   - sgn(ranks) * tau(ranks) / Znum(ranks)                 & 
>                   * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                                            + omg(iz)*mu(im) - 1.5_DP ) )
>               end do
>             end do   ! im loop ends
> 
>             ksq(:,:,iz) = 0._DP
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 ksq(mx,my,iz) = kx(mx)**2 + ky(my)**2
>               end do
>             end do
> 
>             baxfactor    = 1._DP
> 
>            !- for OUTPUT hst/*.mtr.* -
>             domgdz = 0._DP
>             domgdy = 0._DP
>             domgdx = 0._DP
>             gg(1,1) = 1._DP
>             gg(1,2) = 0._DP
>             gg(1,3) = 0._DP
>             gg(2,1) = gg(1,2)
>             gg(2,2) = 1._DP
>             gg(2,3) = 0._DP
>             gg(3,1) = gg(1,3)
>             gg(3,2) = gg(2,3)
>             gg(3,3) = 1._DP
>             metric_l( 1,iz) = zz(iz)   ! [ 1]
>             metric_l( 2,iz) = theta    ! [ 2]
>             metric_l( 3,iz) = omg(iz)  ! [ 3]
>             metric_l( 4,iz) = domgdx   ! [ 4]
>             metric_l( 5,iz) = domgdy   ! [ 5]
>             metric_l( 6,iz) = domgdz   ! [ 6]
>             metric_l( 7,iz) = gg(1,1)  ! [ 7]
>             metric_l( 8,iz) = gg(1,2)  ! [ 8]
>             metric_l( 9,iz) = gg(1,3)  ! [ 9]
>             metric_l(10,iz) = gg(2,2)  ! [10]
>             metric_l(11,iz) = gg(2,3)  ! [11]
>             metric_l(12,iz) = gg(3,3)  ! [12]
>             metric_l(13,iz) = rootg(iz)! [13]
>            !-------------------------
> 
> 
> !!! for the concentric and large-aspect-ratio model !!!
>           else if( trim(equib_type) == "analytic" ) then
> 
>             q_bar = q_0 
>             r_major = 1._DP ! in the R0 unit
> 
>             theta = zz(iz)
> 
>             omg(iz)   = 1._DP                                             &
>                       - eps_r * ( cos( zz(iz) )                           &
>                               + eps_hor * cos( lmmq   * zz(iz) - malpha ) &
>                               + eps_mor * cos( lmmqm1 * zz(iz) - malpha ) &
>                               + eps_por * cos( lmmqp1 * zz(iz) - malpha ) )
> 
>             rootg(iz) = q_0*r_major/omg(iz)
>             dpara(iz) = dz * q_0 * r_major
> 
>                                             ! --- debug
>                                             !    write( olog, * ) " *** z, omg "
>                                             !    do iz = -nz, nz-1
>                                             !      write( olog, * ) zz(iz), omg(iz)
>                                             !    end do
>                                             !    write( olog, * )
> 
>             do im = 0, nm
> 
>               vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )
>               mir(iz,im) = mu(im) * eps_r / ( q_0 * r_major )  &
>                        * ( sin(zz(iz))                                          &
>                          + eps_hor * lmmq   * sin( lmmq   * zz(iz) - malpha )   &
>                          + eps_mor * lmmqm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                          + eps_por * lmmqp1 * sin( lmmqp1 * zz(iz) - malpha ) )
> 
>               do iv = 1, 2*nv
>                 !do my = ist_y, iend_y
>                 !  do mx = -nx, nx
>                                             ! kvd and kvs are revised November 2011
>                                             !             into general species forms. 
>                     !!!!kvd(mx,my,iz,iv,im)=                                            &
>                     !!!!  - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &
>                     !!!!  * ( ky(my) * ( rdeps00 + rdeps1_0 * cos( zz(iz) )             &
>                     !!!!         + rdeps2_10 * cos( lmmq   * zz(iz) - malpha )          &
>                     !!!!         + rdeps1_10 * cos( lmmqm1 * zz(iz) - malpha )          &
>                     !!!!         + rdeps3_10 * cos( lmmqp1 * zz(iz) - malpha ) )        &
>                     !!!!         + ( kx(mx) + s_hat * zz(iz) * ky(my) )                 &
>                     !!!!         * ( sin( zz(iz) )                                      &
>                     !!!!         + eps_hor * lprd   * sin( lmmq   * zz(iz) - malpha )   &
>                     !!!!         + eps_mor * lprdm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                     !!!!         + eps_por * lprdp1 * sin( lmmqp1 * zz(iz) - malpha ) ) &
>                     !!!!     ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     !!!!kvs(mx,my,iz,iv,im) =                                     &
>                     !!!!  - sgn(ranks) * tau(ranks) / Znum(ranks) * ky(my)        & 
>                     !!!!  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                     !!!!                           + omg(iz)*mu(im) - 1.5_DP ) )
> 
>                     !%%% kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im) %%%
>                     !%%% kvs = ky(my) * vsy(iz,iv,im)                          %%%
>                     vdx(iz,iv,im)=                                            &
>                       - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &
>                       * ( 0._DP * ( rdeps00 + rdeps1_0 * cos( zz(iz) )             &
>                              + rdeps2_10 * cos( lmmq   * zz(iz) - malpha )          &
>                              + rdeps1_10 * cos( lmmqm1 * zz(iz) - malpha )          &
>                              + rdeps3_10 * cos( lmmqp1 * zz(iz) - malpha ) )        &
>                              + ( 1._DP + s_hat * zz(iz) * 0._DP )                 &
>                              * ( sin( zz(iz) )                                      &
>                              + eps_hor * lprd   * sin( lmmq   * zz(iz) - malpha )   &
>                              + eps_mor * lprdm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                              + eps_por * lprdp1 * sin( lmmqp1 * zz(iz) - malpha ) ) &
>                          ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vdy(iz,iv,im)=                                            &
>                       - ( vl(iv)**2 + omg(iz)*mu(im) ) * eps_rnew / r_major         &
>                       * ( 1._DP * ( rdeps00 + rdeps1_0 * cos( zz(iz) )             &
>                              + rdeps2_10 * cos( lmmq   * zz(iz) - malpha )          &
>                              + rdeps1_10 * cos( lmmqm1 * zz(iz) - malpha )          &
>                              + rdeps3_10 * cos( lmmqp1 * zz(iz) - malpha ) )        &
>                              + ( 0._DP + s_hat * zz(iz) * 1._DP )                 &
>                              * ( sin( zz(iz) )                                      &
>                              + eps_hor * lprd   * sin( lmmq   * zz(iz) - malpha )   &
>                              + eps_mor * lprdm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                              + eps_por * lprdp1 * sin( lmmqp1 * zz(iz) - malpha ) ) &
>                          ) * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vsy(iz,iv,im) =                                           &
>                       - sgn(ranks) * tau(ranks) / Znum(ranks)                 & 
>                       * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                                                + omg(iz)*mu(im) - 1.5_DP ) )
> 
>                 !  end do
>                 !end do
>               end do
> 
>             end do   ! im loop ends
> 
> 
>             ksq(:,:,iz) = 0._DP
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 ksq(mx,my,iz) = ( kx(mx) + s_hat * zz(iz) * ky(my) )**2 + ky(my)**2
>               end do
>             end do
> 
>             baxfactor    = 1._DP
> 
>            !- for OUTPUT hst/*.mtr.* - !%%% under benchmark %%%
>             domgdz = eps_r * ( sin(zz(iz))                                          &
>                              + eps_hor * lmmq   * sin( lmmq   * zz(iz) - malpha )   &
>                              + eps_mor * lmmqm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                              + eps_por * lmmqp1 * sin( lmmqp1 * zz(iz) - malpha ) )
>             domgdy = - eps_rnew / r_major * (                                  &
>                      - ( sin( zz(iz) )                                         &
>                         + eps_hor * lprd   * sin( lmmq   * zz(iz) - malpha )   &
>                         + eps_mor * lprdm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                         + eps_por * lprdp1 * sin( lmmqp1 * zz(iz) - malpha )   &
>                      ) - (-1._DP/eps_r) * domgdz )
>             domgdx = eps_rnew / r_major * (                                    &
>                      - (                                                       &
>                           rdeps00                                              &
>                         + rdeps1_0 * cos( zz(iz) )                             &
>                         + rdeps2_10 * cos( lmmq   * zz(iz) - malpha )          &
>                         + rdeps1_10 * cos( lmmqm1 * zz(iz) - malpha )          &
>                         + rdeps3_10 * cos( lmmqp1 * zz(iz) - malpha )          &
>                         + s_hat * zz(iz) * ( sin( zz(iz) )                     &
>                         + eps_hor * lprd   * sin( lmmq   * zz(iz) - malpha )   &
>                         + eps_mor * lprdm1 * sin( lmmqm1 * zz(iz) - malpha )   &
>                         + eps_por * lprdp1 * sin( lmmqp1 * zz(iz) - malpha ) ) &
>                      ) - (-s_hat*zz(iz)/eps_r) * domgdz )
>             gg(1,1) = 1._DP
>             gg(1,2) = s_hat*zz(iz)
>             gg(1,3) = 0._DP
>             gg(2,1) = gg(1,2)
>             gg(2,2) = 1._DP + (s_hat*zz(iz))**2
>             gg(2,3) = 1._DP/(r_major*eps_r)
>             gg(3,1) = gg(1,3)
>             gg(3,2) = gg(2,3)
>             gg(3,3) = 1._DP/((r_major*eps_r)**2)
>             metric_l( 1,iz) = zz(iz)   ! [ 1]
>             metric_l( 2,iz) = theta    ! [ 2]
>             metric_l( 3,iz) = omg(iz)  ! [ 3]
>             metric_l( 4,iz) = domgdx   ! [ 4]
>             metric_l( 5,iz) = domgdy   ! [ 5]
>             metric_l( 6,iz) = domgdz   ! [ 6]
>             metric_l( 7,iz) = gg(1,1)  ! [ 7]
>             metric_l( 8,iz) = gg(1,2)  ! [ 8]
>             metric_l( 9,iz) = gg(1,3)  ! [ 9]
>             metric_l(10,iz) = gg(2,2)  ! [10]
>             metric_l(11,iz) = gg(2,3)  ! [11]
>             metric_l(12,iz) = gg(3,3)  ! [12]
>             metric_l(13,iz) = rootg(iz)! [13]
>            !-------------------------
> 
> !!! for s-alpha !!! <--- the current version is the same as "analytic"
>           else if( trim(equib_type) == "s-alpha" .or. trim(equib_type) == "s-alpha-shift" ) then
> 
>             q_bar = q_0
>             r_major = 1._DP ! in the R0 unit
> 
>             if (trim(equib_type) == "s-alpha") then
>               !--- s-alpha model without Shafranov shift -
>               alpha_MHD = 0._DP
>             else if (trim(equib_type) == "s-alpha-shift") then
>               !--- s-alpha model with Shafranov shift ----
>               p_total = 0._DP
>               dp_totaldx = 0._DP
>               beta_total = 0._DP
>               do is = 0, ns-1
>                 p_total = p_total + fcs(is) * tau(is) / Znum(is)
>                 dp_totaldx = dp_totaldx - fcs(is) * tau(is) / Znum(is) * (R0_Ln(is) + R0_Lt(is))
>                 beta_total = beta_total + 2._DP * beta * fcs(is) * tau(is) / Znum(is)
>               end do
>               alpha_MHD = - q_0**2 * r_major * beta_total * dp_totaldx / p_total
>             end if
> 
>             theta = zz(iz)
> 
>             omg(iz)   = 1._DP - eps_r * cos( theta )        ! s-alpha with eps-expansion
>             !omg(iz)   = 1._DP / (1._DP + eps_r * cos( theta )) ! for benchmark
> 
>             rootg(iz) = q_0*r_major/omg(iz)
>             dpara(iz) = dz* q_0 * r_major
> 
>             domgdz  = eps_r * sin( theta )
>             !domgdz  = eps_r * sin( theta ) * omg(iz)**2 ! for benchmark
>             domgdx  = -cos( theta ) / r_major
>             domgdy  = 0._DP
> 
> 
>             gg(1,1) = 1._DP
>             gg(1,2) = s_hat*zz(iz) - alpha_MHD*sin(zz(iz)) ! with Shafranov shift
>             gg(1,3) = 0._DP
>             gg(2,1) = gg(1,2)
>             gg(2,2) = 1._DP + (s_hat*zz(iz) - alpha_MHD*sin(zz(iz)))**2 ! with Shafranov shift
>             gg(2,3) = 1._DP/(r_major*eps_r)
>             gg(3,1) = gg(1,3)
>             gg(3,2) = gg(2,3)
>             gg(3,3) = 1._DP/((r_major*eps_r)**2)
> 
>             kkx = -r_major * (q_0/q_bar) &
>                            * ( gg(1,1)*gg(2,3) - gg(1,2)*gg(1,3) )*domgdz
>             kky =  r_major * (q_bar/q_0) &
>                            * ( domgdx - ( gg(1,2)*gg(2,3) - gg(2,2)*gg(1,3) )*domgdz )
> 
>             do im = 0, nm
> 
>               vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )
> 
>               mir(iz,im) = mu(im) * (q_0/q_bar) * domgdz / ( omg(iz)*rootg(iz) )
> 
>               do iv = 1, 2*nv
>                 !do my = ist_y, iend_y
>                 !  do mx = -nx, nx
> 
>                     !!!!kvd(mx,my,iz,iv,im) =                               &
>                     !!!!   ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   
>                     !!!!  * ( kkx*kx(mx) + kky*ky(my) )                     &
>                     !!!!  * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     !!!!kvs(mx,my,iz,iv,im) =                                     &
>                     !!!!  - sgn(ranks) * tau(ranks) / Znum(ranks) * ky(my)        &
>                     !!!!  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                     !!!!                           + omg(iz)*mu(im) - 1.5_DP ) )  &
>                     !!!!  * (q_bar/q_0)
> 
>                     !%%% kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im) %%%
>                     !%%% kvs = ky(my) * vsy(iz,iv,im)                          %%%
>                     vdx(iz,iv,im) =                                     &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   
>                       * kkx                                             &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vdy(iz,iv,im) =                                     &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / r_major         &   
>                       * kky                                             &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vsy(iz,iv,im) =                                           &
>                       - sgn(ranks) * tau(ranks) / Znum(ranks)                 &
>                       * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                                                + omg(iz)*mu(im) - 1.5_DP ) )  &
>                       * (q_bar/q_0)
> 
>                 !  end do
>                 !end do
>               end do
> 
>             end do   ! im loop ends
> 
> 
>             ksq(:,:,iz) = 0._DP
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 ksq(mx,my,iz) = ( kx(mx) + ( s_hat * zz(iz) - alpha_MHD*sin(zz(iz)) ) &
>                                 * ky(my) )**2 + ky(my)**2 ! with Shafranov shift
>               end do
>             end do
> 
>             baxfactor    = 1._DP
> 
>            !- for OUTPUT hst/*.mtr.* -
>             metric_l( 1,iz) = zz(iz)   ! [ 1]
>             metric_l( 2,iz) = theta    ! [ 2]
>             metric_l( 3,iz) = omg(iz)  ! [ 3]
>             metric_l( 4,iz) = domgdx   ! [ 4]
>             metric_l( 5,iz) = domgdy   ! [ 5]
>             metric_l( 6,iz) = domgdz   ! [ 6]
>             metric_l( 7,iz) = gg(1,1)  ! [ 7]
>             metric_l( 8,iz) = gg(1,2)  ! [ 8]
>             metric_l( 9,iz) = gg(1,3)  ! [ 9]
>             metric_l(10,iz) = gg(2,2)  ! [10]
>             metric_l(11,iz) = gg(2,3)  ! [11]
>             metric_l(12,iz) = gg(3,3)  ! [12]
>             metric_l(13,iz) = rootg(iz)! [13]
>            !-------------------------
> 
> 
> !!! for circular MHD equilibrium !!!
>           else if( trim(equib_type) == "circ-MHD" ) then
> 
>             q_bar = dsqrt( 1._DP - eps_r**2 )*q_0
>             r_major = 1._DP ! in the R0 unit
> 
>             theta = 2._DP*atan( sqrt( (1._DP+eps_r)/(1._DP-eps_r) ) &
>                               * tan(zz(iz)/2._DP) )
> 
>             omg(iz)   = sqrt( q_bar**2 + eps_r**2 ) &
>                       / ( 1._DP + eps_r*cos( theta ) ) / q_bar
> 
>             rootg(iz) = q_0*r_major*( 1._DP+eps_r*cos(theta) )**2
>             dpara(iz) = dz * omg(iz) * rootg(iz)
> 
> 
>             domgdz  = eps_r * sin(theta) * sqrt( q_bar**2 + eps_r**2 ) &
>                        / ( 1._DP + eps_r * cos( theta ) )**2           &
>                        / ( 1._DP - eps_r * cos( zz(iz)) ) / q_0
> 
>             domgdx  = -( cos(theta)                                            &
>                          - eps_r*(1._DP-s_hat+eps_r**2*q_0**2/q_bar**2)        &
>                                 *(1._DP+eps_r*cos(theta))/(q_bar**2+eps_r**2)  &
>                          - eps_r*sin(theta)**2/(1._DP-eps_r**2)                &
>                          ) / ((1._DP + eps_r*cos(theta))**2)                   &
>                            * sqrt(q_bar**2+eps_r**2) / q_bar / r_major
> 
>             domgdy  = 0._DP
> 
>             gg(1,1) = (q_0/q_bar)**2
>             gg(1,2) = ( s_hat*zz(iz)*q_0/q_bar - eps_r*sin(zz(iz))/(1._DP-eps_r**2) )*q_0/q_bar
>             gg(1,3) = - sin(zz(iz))/(1._DP-eps_r**2)/r_major*q_0/q_bar
>             gg(2,1) = gg(1,2)
>             gg(2,2) = (s_hat*zz(iz)*q_0/q_bar)**2 - 2._DP*q_0/q_bar*s_hat*zz(iz)*eps_r*sin(zz(iz))/(1._DP-eps_r**2) &
>                         + (q_bar**2+eps_r**2)/((1._DP+eps_r*cos(theta))**2)/(q_0**2)   &
>                         + (eps_r*sin(zz(iz)))**2/(1._DP-eps_r**2)**2
>             gg(2,3) = ( -s_hat*zz(iz)*q_0/q_bar*sin(zz(iz))/(1._DP-eps_r**2)           &
>                            + ((q_bar/q_0)**2)/((1._DP+eps_r*cos(theta))**2)/eps_r      &
>                            + eps_r*(sin(zz(iz))**2)/((1._DP-eps_r**2)**2)              &
>                          ) / r_major
>             gg(3,1) = gg(1,3)
>             gg(3,2) = gg(2,3)
>             gg(3,3) = ( ((q_bar/q_0)**2)/((1._DP+eps_r*cos(theta))**2)/(eps_r**2)  &
>                            + (sin(zz(iz))**2)/((1._DP-eps_r**2)**2)                &
>                          ) / (r_major**2)
> 
>             kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )
>             kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )
> 
>             do im = 0, nm
> 
>               vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )
> 
>               mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )
> 
>               do iv = 1, 2*nv
>                 !do my = ist_y, iend_y
>                 !  do mx = -nx, nx
> 
>                     !!!!kvd(mx,my,iz,iv,im)=                                        &
>                     !!!!   ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &
>                     !!!!  * ( kkx*kx(mx) + kky*ky(my) )                             &
>                     !!!!  * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     !!!!kvs(mx,my,iz,iv,im) =                                     &
>                     !!!!  - sgn(ranks) * tau(ranks) / Znum(ranks) * ky(my)        &
>                     !!!!  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                     !!!!                           + omg(iz)*mu(im) - 1.5_DP ) )  
> 
>                     !%%% kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im) %%%
>                     !%%% kvs = ky(my) * vsy(iz,iv,im)                          %%%
>                     vdx(iz,iv,im)=                                              &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &
>                       * kkx                                                     &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vdy(iz,iv,im)=                                              &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )     &
>                       * kky                                                     &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vsy(iz,iv,im) =                                           &
>                       - sgn(ranks) * tau(ranks) / Znum(ranks)                 &
>                       * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                                                + omg(iz)*mu(im) - 1.5_DP ) )  
> 
> 
>                 !  end do
>                 !end do
>               end do
> 
>             end do   ! im loop ends
> 
> 
>             ksq(:,:,iz) = 0._DP
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &
>                               + 2._DP*kx(mx)*ky(my)*gg(1,2) &
>                               + (ky(my)**2)*gg(2,2)
>               end do
>             end do
> 
>             baxfactor    = 1._DP
> 
>            !- for OUTPUT hst/*.mtr.* -
>             metric_l( 1,iz) = zz(iz)   ! [ 1]
>             metric_l( 2,iz) = theta    ! [ 2]
>             metric_l( 3,iz) = omg(iz)  ! [ 3]
>             metric_l( 4,iz) = domgdx   ! [ 4]
>             metric_l( 5,iz) = domgdy   ! [ 5]
>             metric_l( 6,iz) = domgdz   ! [ 6]
>             metric_l( 7,iz) = gg(1,1)  ! [ 7]
>             metric_l( 8,iz) = gg(1,2)  ! [ 8]
>             metric_l( 9,iz) = gg(1,3)  ! [ 9]
>             metric_l(10,iz) = gg(2,2)  ! [10]
>             metric_l(11,iz) = gg(2,3)  ! [11]
>             metric_l(12,iz) = gg(3,3)  ! [12]
>             metric_l(13,iz) = rootg(iz)! [13]
>            !-------------------------
> 
> !!!! for VMEC equilibrium !!!
> !          else if( trim(equib_type) == "vmec" ) then
> !
> !            q_bar = q_0 
> !            theta = zz(iz)
> !
> !            call vmecin_coeff( rad_a, R0_unit, rho2R_0, q_input, theta,  &
> !                               alpha_fix, r_0, r_minor, s_hat,           &
> !                               gdwss, gdwtt, gdwzz, gdwst, gdwsz, gdwtz, &
> !                               gupss, guptt, gupzz, gupst, gupsz, guptz, &
> !                               babs, Bs, Bth, Bzt, dBds, dBdt, dBdz,     &
> !                               dBdt_mir, vmec_rootg, rootgft, rootgbz )
> !
> !            omg(iz)   = babs
> !
> !            rootg(iz) = vmec_rootg * R0_unit * R0_unit * R0_unit
> !            dpara(iz) = dz * babs * rootgft * b0b00
> !
> !
> !
> !            do im = 0, nm
> !
> !              vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )
> !              mir(iz,im) = mu(im) * dBdt_mir / babs / rootgft / b0b00
> !
> !              do iv = 1, 2*nv
> !                do my = ist_y, iend_y
> !                  do mx = -nx, nx
> !
> !                    kvd(mx,my,iz,iv,im) =                                              &
> !                      - (( vl(iv)**2 + omg(iz)*mu(im) ) / rootgbz /babs/babs/babs )    &
> !                      * ((r_0/q_0) * ky(my)                                            &
> !                      * ( ( (Bs/r_a) + Bzt * (q_0/r_0) * s_hat * zz(iz) ) * dBdt       &
> !                         +( (Bs/r_a) * q_0 - Bth * (q_0/r_0) * s_hat * zz(iz) ) * dBdz &
> !                         -( Bth + Bzt * q_0 ) * dBds / r_a )                           &
> !                      + kx(mx) * ( Bzt * dBdt - Bth * dBdz ))                          &
> !                      * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> !                                              ! --- k*v_d term
> !
> !                    kvs(mx,my,iz,iv,im) =                                               &
> !                      - sgn(ranks) * ky(my)                                             &
> !                      * ((r_0/q_0) * (Bth + Bzt * q_0) / rootgbz / babs / babs)         &
> !                      * ( R0_Ln(ranks)                                                  &
> !                        + R0_Lt(ranks) * (0.5_DP*vl(iv)**2 + omg(iz)*mu(im) - 1.5_DP) ) &
> !                      * tau(ranks) / Znum(ranks)
> !                                              ! --- k*v_* term
> !                  end do
> !                end do
> !              end do
> !
> !            end do   ! im loop ends
> !
> !
> !            do my = ist_y, iend_y
> !              do mx = -nx, nx
> !                ksq(mx,my,iz)  = (r_a * kx(mx))**2  * gupss                             &
> !                   + ky(my)**2  * ( (r_0/q_0)**2                                        &
> !                   * ( gupzz + guptt * q_0 **2 - guptz * 2._DP * q_0 )                  &
> !                   + 2._DP * s_hat * (r_0/q_0) * zz(iz) * r_a * ( gupst * q_0 - gupsz ) &
> !                   + r_a * r_a * gupss * (s_hat**2) * (zz(iz)**2) )                     &
> !                   + (r_a * kx(mx)) * ky(my) * 2._DP * ( (r_0/q_0)                      &
> !                   * ( gupst * q_0 - gupsz ) + r_a * gupss * s_hat * zz(iz) ) 
> !                                              ! --- squere of k_perp 
> !              end do
> !            end do
> !
> !            baxfactor    = b0b00                ! --- For the use in caldlt
> !
> 
> !  this is new vmec-BoozXform interface  by M. Nakata & M. Nunami  (Aug. 2016)
>           else if( trim(equib_type) == "vmec" ) then
> 
>             q_bar = q_0
>             isw = 1
>             r_major = 1._DP ! in the R0 unit
> 
>             call vmecbzx_boozx_coeff( isw,  nss,  ntheta,  nzeta,  s_input,     iz, zz(iz),  lz_l,   &  ! input 
>                                        s_0,       q_0,     s_hat,    eps_r, phi_ax,          &  ! output
>                                    omg(iz), rootg(iz),    domgdx,   domgdz, domgdy,          &
>                                    gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),                  &
>                                    gg(2,3),   gg(3,3)  )
> 
>             dpara(iz) = dz * omg(iz) * rootg(iz)
> 
>             kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )
>             kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )
> 
>             do im = 0, nm
> 
>               vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )
> 
>               mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )
> 
>               do iv = 1, 2*nv
>                 !do my = ist_y, iend_y
>                 !  do mx = -nx, nx
> 
>                     !!!!kvd(mx,my,iz,iv,im) =                                        &
>                     !!!!   ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &
>                     !!!!  * ( kkx*kx(mx) + kky*ky(my) )                              &
>                     !!!!  * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &
>                     !!!! - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term 
>                     !!!!  * ( beta*(R0_Ln(ranks) + R0_Lt(ranks))*ky(my) )            &
>                     !!!!  * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     !!!!kvs(mx,my,iz,iv,im) =                                     &
>                     !!!!  - sgn(ranks) * tau(ranks) / Znum(ranks) * ky(my)        &
>                     !!!!  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                     !!!!                           + omg(iz)*mu(im) - 1.5_DP ) )  
> 
>                     !%%% kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im) %%%
>                     !%%% kvs = ky(my) * vsy(iz,iv,im)                          %%%
>                     vdx(iz,iv,im) =                                              &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &
>                       * kkx                                                      &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
> 
>                     vdy(iz,iv,im) =                                              &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &
>                       * kky                                                      &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &
>                      - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term 
>                       * ( beta*(R0_Ln(ranks) + R0_Lt(ranks)) )                   &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vsy(iz,iv,im) =                                           &
>                       - sgn(ranks) * tau(ranks) / Znum(ranks)                 &
>                       * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                                                + omg(iz)*mu(im) - 1.5_DP ) )  
> 
> 
>                 !  end do
>                 !end do
>               end do
> 
>             end do   ! im loop ends
> 
> 
>             ksq(:,:,iz) = 0._DP
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &
>                               + 2._DP*kx(mx)*ky(my)*gg(1,2) &
>                               + (ky(my)**2)*gg(2,2)
>               end do
>             end do
> 
>             baxfactor    = 1._DP
> 
>            !- for OUTPUT hst/*.mtr.* -
>             metric_l( 1,iz) = zz(iz)   ! [ 1]
>             metric_l( 2,iz) = phi_ax   ! [ 2] Axisymetric toroidal angle
>             metric_l( 3,iz) = omg(iz)  ! [ 3]
>             metric_l( 4,iz) = domgdx   ! [ 4]
>             metric_l( 5,iz) = domgdy   ! [ 5]
>             metric_l( 6,iz) = domgdz   ! [ 6]
>             metric_l( 7,iz) = gg(1,1)  ! [ 7]
>             metric_l( 8,iz) = gg(1,2)  ! [ 8]
>             metric_l( 9,iz) = gg(1,3)  ! [ 9]
>             metric_l(10,iz) = gg(2,2)  ! [10]
>             metric_l(11,iz) = gg(2,3)  ! [11]
>             metric_l(12,iz) = gg(3,3)  ! [12]
>             metric_l(13,iz) = rootg(iz)! [13]
>            !-------------------------
> 
> 
>           else if( trim(equib_type) == "eqdsk" ) then
> 
>             q_bar = q_0
>             isw = 1
>             r_major = 1._DP ! in the R0 unit
> 
>             call igs_coeff( isw,  mc_type,   nss,    ntheta,  s_input, zz(iz), lz_l, &  ! input 
>                                        s_0,       q_0,     s_hat,    eps_r,  theta,       &  ! output
>                                    omg(iz), rootg(iz),    domgdx,   domgdz, domgdy,       &
>                                    gg(1,1),   gg(1,2),   gg(1,3),  gg(2,2),               &
>                                    gg(2,3),   gg(3,3)  )
> 
>             dpara(iz) = dz * omg(iz) * rootg(iz)
> 
>             kkx =  r_major*( -domgdy + (gg(1,3)*gg(1,2) - gg(1,1)*gg(2,3))*domgdz/omg(iz)**2 )
>             kky =  r_major*(  domgdx + (gg(1,3)*gg(2,2) - gg(1,2)*gg(2,3))*domgdz/omg(iz)**2 )
> 
>             do im = 0, nm
> 
>               vp(iz,im)  = sqrt( 2._DP * mu(im) * omg(iz) )
> 
>               mir(iz,im) = mu(im) * domgdz / ( omg(iz)*rootg(iz) )
> 
>               do iv = 1, 2*nv
>                 !do my = ist_y, iend_y
>                 !  do mx = -nx, nx
> 
>                     !!!!kvd(mx,my,iz,iv,im) =                                        &
>                     !!!!   ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &
>                     !!!!  * ( kkx*kx(mx) + kky*ky(my) )                              &
>                     !!!!  * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &
>                     !!!! - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term 
>                     !!!!  * ( beta*(R0_Ln(ranks) + R0_Lt(ranks))*ky(my) )            &
>                     !!!!  * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     !!!!kvs(mx,my,iz,iv,im) =                                     &
>                     !!!!  - sgn(ranks) * tau(ranks) / Znum(ranks) * ky(my)        &
>                     !!!!  * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                     !!!!                           + omg(iz)*mu(im) - 1.5_DP ) )  
> 
>                     !%%% kvd = kx(mx) * vdx(iz,iv,im) + ky(my) * vdy(iz,iv,im) %%%
>                     !%%% kvs = ky(my) * vsy(iz,iv,im)                          %%%
>                     vdx(iz,iv,im) =                                              &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &
>                       * kkx                                                      &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vdy(iz,iv,im) =                                              &
>                        ( vl(iv)**2 + omg(iz)*mu(im) ) / ( r_major*omg(iz) )      &
>                       * kky                                                      &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )                &
>                      - real(ibprime,kind=DP) * vl(iv)**2 / r_major / omg(iz)**2  & ! grad-p (beta-prime) term 
>                       * ( beta*(R0_Ln(ranks) + R0_Lt(ranks)) )                   &
>                       * ( sgn(ranks) * tau(ranks) / Znum(ranks) )
> 
>                     vsy(iz,iv,im) =                                           &
>                       - sgn(ranks) * tau(ranks) / Znum(ranks)                 &
>                       * ( R0_Ln(ranks) + R0_Lt(ranks) * ( 0.5_DP*vl(iv)**2    &
>                                                + omg(iz)*mu(im) - 1.5_DP ) )  
> 
> 
>                 !  end do
>                 !end do
>               end do
> 
>             end do   ! im loop ends
> 
> 
>             ksq(:,:,iz) = 0._DP
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 ksq(mx,my,iz) = (kx(mx)**2)*gg(1,1)         &
>                               + 2._DP*kx(mx)*ky(my)*gg(1,2) &
>                               + (ky(my)**2)*gg(2,2)
>               end do
>             end do
> 
>             baxfactor    = 1._DP
> 
>            !- for OUTPUT hst/*.mtr.* -
>             metric_l( 1,iz) = zz(iz)   ! [ 1]
>             metric_l( 2,iz) = theta    ! [ 2]
>             metric_l( 3,iz) = omg(iz)  ! [ 3]
>             metric_l( 4,iz) = domgdx   ! [ 4]
>             metric_l( 5,iz) = domgdy   ! [ 5]
>             metric_l( 6,iz) = domgdz   ! [ 6]
>             metric_l( 7,iz) = gg(1,1)  ! [ 7]
>             metric_l( 8,iz) = gg(1,2)  ! [ 8]
>             metric_l( 9,iz) = gg(1,3)  ! [ 9]
>             metric_l(10,iz) = gg(2,2)  ! [10]
>             metric_l(11,iz) = gg(2,3)  ! [11]
>             metric_l(12,iz) = gg(3,3)  ! [12]
>             metric_l(13,iz) = rootg(iz)! [13]
>            !-------------------------
> 
> 
>           else
> 
>             write( olog, * ) " # wrong choice of the equilibrium "
>             call flush(olog)
>             call MPI_Finalize(ierr_mpi)
>             stop
> 
>           end if
> 
> 
>           do im = 0, nm
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 kmo           = sqrt( 2._DP * ksq(mx,my,iz) * mu(im) / omg(iz) ) &
>                                * dsqrt( tau(ranks)*Anum(ranks) ) / Znum(ranks)
>                 call math_j0( kmo, j0(mx,my,iz,im) )
>                 call math_j1( kmo, j1(mx,my,iz,im) )
>                 call math_j2( kmo, j2(mx,my,iz,im) )
>               end do
>             end do
>           end do
> 
> 
>           do my = ist_y, iend_y
>             do mx = -nx, nx
>               bb     = ksq(mx,my,iz) / omg(iz)**2 &
>                         * tau(ranks)*Anum(ranks)/(Znum(ranks)**2)
>               call math_g0( bb, g0(mx,my,iz) )
>             end do
>           end do
> 
> 
> !!!! debug (Jan 2012)
> !          write( olog, fmt="(1p,10e15.7)" )    &
> !            zz(iz), omg(iz), mir(iz,0), dpara(iz), jcob(iz), &
> !            ksq(1,2,iz), kvs(1,2,iz,1,0), kvd(1,2,iz,1,0), j0(1,2,iz,0), g0(1,2,iz)
> !!!! debug (Jan 2012)
> 
> 
>         end do   ! iz loop ends
> 
> !- OUTPUT ascii data hst/*.mtr.* -
>         call MPI_gather(metric_l(1,-nz), num_omtr*2*nz, MPI_DOUBLE_PRECISION,        &
>                         metric_g(1,-global_nz), num_omtr*2*nz, MPI_DOUBLE_PRECISION, &
>                         0, zsp_comm_world, ierr_mpi)
>         if ( rankg == 0 ) then
>           do iz = -global_nz, global_nz-1
>             write( omtr, fmt="(f15.8,SP,256E24.14e3)") metric_g(:,iz)
>           end do
>           call flush(omtr)
>         end if
> !---------------------------------
> 
> ! --- operator settings ---
> 
> 
>         cfsrf   = 0._DP
>         cfsrf_l = 0._DP
>         do iz = -nz, nz-1
> !          cfsrf_l   = cfsrf_l + 1._DP / omg(iz)
>           cfsrf_l   = cfsrf_l + rootg(iz)
>                                             ! normalization coefficient for 
>                                             ! the surface average
>         end do
> 
>         call MPI_Allreduce( cfsrf_l, cfsrf, 1, MPI_DOUBLE_PRECISION, &
>                             MPI_SUM, zsp_comm_world, ierr_mpi )
> 
> 
>                                             ! --- debug
>                                             !    write( olog, * ) " *** z, omg "
>                                             !    do iz = -nz, nz-1
>                                             !      write( olog, * ) zz(iz), omg(iz)
>                                             !    end do
>                                             !    write( olog, * )
> 
> 
>         if ( vel_rank == 0 ) then
>           do iz = -nz, nz-1
>             !dvp(iz)   = vp(iz,1)
>             dvp(iz)  = sqrt( 2._DP * (0.5_DP * dm**2) * omg(iz) )
>           end do
>         end if
> 
>         call MPI_Bcast( dvp, 2*nz, MPI_DOUBLE_PRECISION, 0, &
>                         vel_comm_world, ierr_mpi )
> 
> 
>         do my = ist_y_g, iend_y_g
>           ck(my-ist_y_g)   = exp( ui * 2._DP * pi * del_c &
>                                      * real( n_tht * my, kind=DP ) )
>           dj(my-ist_y_g)   = - m_j * n_tht * my
>                                             !  del_c = q_0*n_alp-int(q_0*n_alp)
>                                             !  m_j   = 2*n_alp*q_d
>         end do
> 
> 
>         do im = 0, nm
>           do iv = 1, 2*nv
>             do iz = -nz, nz-1
>               fmx(iz,iv,im)   = exp( - 0.5_DP * vl(iv)**2 - omg(iz) * mu(im) ) &
>                               / sqrt( twopi**3 )
>             end do
>           end do
>         end do
> 
>         allocate( ww(-nx:nx,0:ny,-nz:nz-1) )
> 
> ! --- GK polarization factor for efield calculation 
>         fct_poisson(:,:,:) = 0._DP
>         fct_e_energy(:,:,:) = 0._DP
> 
>         ww(:,:,:) = 0._DP
>         do iz = -nz, nz-1
>           do my = ist_y, iend_y
>             do mx = -nx, nx
> 
>               if ( rankw == 0 .and. mx == 0 .and. my == 0 ) then !- (0,0) mode
> 
>                 fct_poisson(mx,my,iz) = 0._DP
>                 fct_e_energy(mx,my,iz) = 0._DP
> 
>               else
> 
>                 ww(mx,my,iz) = lambda_i * ksq(mx,my,iz)
>                 do is = 0, ns-1
>                   bb   = ksq(mx,my,iz) / omg(iz)**2 &
>                           * tau(is)*Anum(is)/(Znum(is)**2)
>                   call math_g0( bb, gg0 )
>                   ww(mx,my,iz) = ww(mx,my,iz)  &
>                                + Znum(is) * fcs(is) / tau(is) * ( 1._DP - gg0 )
>                 end do
>                 fct_poisson(mx,my,iz) = 1._DP / ww(mx,my,iz)
>                 fct_e_energy(mx,my,iz) = ww(mx,my,iz)
> 
>               end if
> 
>             end do
>           end do
>         end do
> 
> 
> ! --- ZF-factor for adiabatic model
>         if ( ns == 1 ) then
> 
>           ww(:,:,:) = 0._DP
>           do iz = -nz, nz-1
>             my = 0
>               do mx = -nx, nx
>                 ww(mx,my,iz) = ( 1._DP - g0(mx,my,iz) )       &
>                              / ( 1._DP - g0(mx,my,iz) + tau(0)*tau_ad )
>               end do
>           end do
> 
>           call intgrl_fsrf ( ww, fctgt )
> 
>           if ( rankw == 0 )  then
>             fctgt(0)   = ( 1._DP - g0(0,0,0) ) / ( 1._DP - g0(0,0,0) + tau(0)*tau_ad )
>                                               ! g0(0,0,iz) has no z dependence
>           endif
> 
>         endif
> 
>         deallocate( ww )
> 
>         allocate( wf(-nx:nx,0:ny,-nz:nz-1,1:2*nv,0:nm) )
>         allocate( nw(-nx:nx,0:ny,-nz:nz-1) )
>         wf(:,:,:,:,:) = ( 0._DP, 0._DP )
>         nw(:,:,:) = ( 0._DP, 0._DP )
> 
> ! --- GK polarization factor for mfield calculation 
>         fct_ampere(:,:,:) = 0._DP
>         fct_m_energy(:,:,:) = 0._DP
> 
>         if ( beta .ne. 0._DP ) then
>        
>           do im = 0, nm
>             do iv = 1, 2*nv
>               do iz = -nz, nz-1
>                 do my = ist_y, iend_y
>                   do mx = -nx, nx
>                     wf(mx,my,iz,iv,im) = Znum(ranks) * fcs(ranks) / Anum(ranks)  &
>                                        * vl(iv)**2 * j0(mx,my,iz,im)**2 * fmx(iz,iv,im)
>                   end do
>                 end do
>               end do
>             end do
>           end do
>   
>           call intgrl_v0_moment_ms ( wf, nw )
>   
>           do iz = -nz, nz-1
>             do my = ist_y, iend_y
>               do mx = -nx, nx
>                 fct_ampere(mx,my,iz) = 1._DP / real( ksq(mx,my,iz) + beta * nw(mx,my,iz), kind=DP )
>                 fct_m_energy(mx,my,iz) = ksq(mx,my,iz) / beta
>               end do
>             end do
>           end do
>   
>           if ( rankw == 0 ) then
>             do iz = -nz, nz-1
>               fct_ampere(0,0,iz) = 0._DP
>               fct_m_energy(0,0,iz) = 0._DP
>             end do
>           end if
> 
>         end if
> 
>         deallocate( wf )
>         deallocate( nw )
406,407d1788
< ! --- coordinate settings (time-indep.) ---
<         call geom_init_kxkyzvm(lx, ly, eps_r)
411a1793,1799
>         !if (trim(time_advnc) == "imp_colli" .or. trim(time_advnc) == "auto_init") then
>         if (trim(col_type) == "full" .or. trim(col_type) == "lorentz" .or. trim(time_advnc) == "imp_colli") then
>           call colliimp_set_param
>         end if
>         !!! call colliimp_set_param
>         call dtc_init( lx, ly, vmax )
> 
441,451d1828
< ! --- coordinate settings (explicitly time-dependent metrics) ---
<         call geom_init_metric
< 
< ! --- operator settings (time-dependent through metrics) ---
<         call geom_set_operators
<         if (trim(col_type) == "full" .or. trim(col_type) == "lorentz" .or. trim(time_advnc) == "imp_colli") then
<           call colliimp_set_param
<         end if
< 
< ! --- initial estimate of time steps ---
<         call dtc_init( lx, ly, vmax )
594,602d1970
< 
<      !%%% For shearflow rotating flux tube model %%%
<       if (gamma_e /= 0._DP .and. trim(flag_shearflow) =="rotating") then
<         call geom_reset_time(time)
<         if (trim(col_type) == "full" .or. trim(col_type) == "lorentz" .or. trim(time_advnc) == "imp_colli") then
<           call colliimp_set_param
<         end if
<       end if
<      !%%%
